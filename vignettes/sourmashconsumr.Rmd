---
title: "Using sourmashconsumr to parse, analyze, and visualize the outputs of the sourmash pythong package"
date: November 2022
output: 
  rmarkdown::html_vignette:
    toc: true
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Using sourmashconsumr to parse, analyze, and visualize the outputs of the sourmash pythong package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(sourmashconsumr)
```

```{r, eval = F, echo = F}
# note this block is not rendered in the readme as echo = F.
# build with:
# devtools::build_rmd("vignettes/sourmashconsumr.Rmd")
```

# Introduction

[Sourmash](https://sourmash.readthedocs.io/en/latest/) is a tool that facilitates lightweight and rapid comparisons between potentially very large sets of sequencing data (see [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6720031/) and [here](https://www.biorxiv.org/content/10.1101/2022.01.11.475838v2.abstract)).

Sourmashconsumr provides parsing, analysis, and visualization functions for outputs generated by the sourmash commands `sketch`, `compare`, `gather`, and `taxonomy annotate`.
The sourmash outputs that sourmashconsumr works with are information-rich text files (either CSV or JSON). 
The sourmashconsumr functions are designed to help interpret these outputs.

sourmashconsumr does not re-implement any of the functionality in the sourmash python package. 

## How sourmash works

Sourmash uses FracMinHash sketching to generate compressed representations of sequencing data.
Two core parameters determine which sequences are represented in these sketches: k-mers size and scaled value.
The k-mer size dictates the length of sequences represented in the sketch; defaults are *k* = 21, *k* = 31, and *k* = 51.
While these sizes are somewhat empiric, overlap between related genomic sequences for a given k-mer size roughly approximates taxonomic relationships, with substantial overlap at *k* = 21 roughly approximating genus-level relatedness, *k* = 31 species-level, and *k* = 51 strain-level.
The scaled value dictates the fraction of k-mers in the original sequence that get included in the sketch.
Approximately 1/scaled value of k-mers in the original sequence get included in the sketch.
The sourmash defaults are 1000, 2000, and 10,000.
The scaled value takes advantage of the fact that a subset of data can be used to accurately estimate things like similarity and containment and dramatically sub-samples the original sequences thus facilitating rapid comparisons even between very large data sets.

## Sourmash outputs that sourmashconsumr works on

The sourmashconsumr package works with outputs from the following sourmash commands.
We provide a brief description of each command, but be sure to check the [sourmash documentation](https://sourmash.readthedocs.io/en/latest/) for a more complete explanation and examples.

+ `sourmash sketch`: Produces sketches for each sequence. Any sequencing data (DNA, protein, or 6-frame translation) in FASTQ or FASTA format can be sketched. Files produced by `sourmash sketch` are referred to as *signatures* because they may contain many sketches (one sketch for each k-mer size).
+ `sourmash compare`: Compares many sketches and produces a (dis)similarity matrix. If abundance information is ignored, the output represents jaccard distance. If abundance information is included, the output represents angular distance.
+ `sourmash gather`: Compares each query sketch against all sketches in a database to identify the minimum set of sketches that contain all of the known k-mers in the query. Typically, `sourmash gather` is run on metagenomes to determine all of the genomes that are contained within the sample, however `sourmash gather` can be used to assess containment between a query and a large database of sequences (e.g. for contamination discovery).
+ `sourmash taxonomy annotate`: Assigns taxonomic lineages to the sourmash gather matches.

# Installation

You can install the development version of sourmashconsumr from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("Arcadia-Science/sourmashconsumr")
```

Eventually, we hope to release sourmashconsumr on CRAN and to provide a conda-forge package. 
We'll update these instructions once we've done that.

To access the functions in the sourmashconsumr package:

``` r
library(sourmashconsumr)
```

# Quickstart 

# Problems & getting help

If you encounter any problems using sourmashconsumr, please post an issue on the issue tracker: https://github.com/Arcadia-Science/sourmashconsumr/issues.
If you encounter problems with sourmash, please post an issue on the sourmash issue tracker: https://github.com/sourmash-bio/sourmash/issues.

# Notes about the example data and package file paths

The sourmashconsumr package comes with a few example data sets that you can load to get a feel for data formats and to play around with the functions in the package.

You can access the data using the `data()` command.
Below we show this for the what the sourmash compare output looks like after it has been read into R using `read_compare_csv()`:

```{r example_data_compare}
data(gut_compare_df)
gut_compare_df
```

The other available data sets can be loaded with the following code:
```{r example_data}
data(gut_signatures_df)
data(gut_gather_df)
data(gut_taxonomy_annotate_df)
```

We've documented the content of each of these data sets, including an explanation for what is encoded by each column.
Use the following code to access this information:

``` r
?gut_gather_df
```

## Explanation about accessing external files packaged with sourmashconsumr

Because some of the functions read external files, we've also included example sourmash outputs with the package to demonstrate how the `read*()` functions work.
Specifying paths to data files packaged with an R package is a bit ugly...it takes advantage of the base R function `system.file` and information about the package to derive the file paths.
While this is helpful because it allows anyone to access the files in a package no matter where the package is installed thereby allowing anyone to run the code in the vignette, the syntax can be confusing because the example ends up looking a lot different than the code you would actually write. 
Whenever you see `system.file()` in this vignette, know that when you go to run similar code on your own sourmash outputs, you need to specify the path to your file to run the command without all of the accompanying `system.file()` code.
See an example below:

```r
# how we have to specify paths so that anyone can access the package data
fpath <- system.file("extdata", "SRR5947006.sig.gz", package="sourmashconsumr")
signature_df <- read_signature(fpath)
```

```r
# how you will specify a path when you actually run the code
signature_df <- read_signature("path/to/your_signature_file.sig")
```

## Origins of the example data

The example data are six samples from the [iHMP IBD](https://ibdmdb.org/) cohort. 
These are short shotgun metagenomes from stool microbiomes. 
While the iHMP was a longitudinal study, the samples in the example data are all time point 1 samples taken from different individuals. 
All individuals were symptomatic at time point 1, but three individuals were diagnosed with Crohnâ€™s disease (cd) at the end of the year, while three individuals were not (nonIBD).

| run_accession | group |
|---------------|-------|
| SRR5936131    |	cd    |
| SRR5947006    |	cd    |
| SRR5935765    |	cd    |
| SRR5936197    |	nonibd|
| SRR5946923    |	nonibd|
| SRR5946920    |	nonibd|

You can see the complete set of commands that were used to generate the data [here](ADD LINK ONCE PR IS MERGED).

# Complete start

## Reading sourmash outputs into R


## Working with sourmash signatures (FracMinHash sketches)

Sourmash signatures are compressed representations of sequencing data.
This data can be used for many different purposes such as [machine learning](https://www.biorxiv.org/content/10.1101/2022.06.30.498290v1), differential k-mer abundance analysis, and sequencing depth/rarefaction analysis.

### Reading sourmash sigatures into R

To facilitate these types of analyses in R, the sourmashconsumr function `read_signature()` reads sourmash signatures produced by the `sourmash sketch` or `sourmash compute` function into a data frame.

```{r read_signature_one}
fpath <- system.file("extdata", "SRR5947006.sig.gz", package="sourmashconsumr")
signature_df <- read_signature(fpath)
head(signature_df)
```

If you have many signatures that you would like to read into the same data frame, you can use `purrr`:

```{r read_signature_many}
library(purrr)

# grab the files paths for sourmashconsumr example data
fpaths <- system.file("extdata", package = "sourmashconsumr") %>% list.files()
fpaths <- fpaths[grepl(pattern = ".sig.gz", x = fpaths)]
print(fpaths)
# read in the signature files
#signature_df <- fpaths %>%
#  map_dfr(read_signature)

#head(signature_df)
```

Signatures that are uncompressed (`*.sig`) or gzip compressed (`*.sig.gz`) can be read in by `read_signature()`.

### Visualizing shared k-mer content between samples with an upset plot

The functions `from_signatures_to_upset_df()`, `plot_signatures_upset()` produce an upset plot that depicts the number of k-mers shared between sets of samples. 
The absolute size of the intersection is the number of shared hashes (k-mers) in scaled FracMinHash sketches (see [How sourmash works] for an explanation of sketches and their content.).

An upset plot is an alternative to a venn diagram; the bottom half of the plot shows which samples have shared content while the top half of the plot shows the size of the intersection between the specified samples.

This plot is good for visualizing the exact sequencing content overlap between samples. 
If there is a lot of variation in the samples, it might be difficult to interpret the plot as there may be many intersections. 
Still, it provides a nice complement to the sourmash compare results and plots as it gives more information about the nature of the intersections between samples.

```{r}
data(gut_signatures_df)

gut_signatures_df <- gut_signatures_df %>%
  dplyr::filter(ksize == 31)

gut_signatures_upset_df <- from_signatures_to_upset_df(signatures_df = gut_signatures_df)
head(gut_signatures_upset_df)
```

```{r, fig.width=8}
plot_signatures_upset(gut_signatures_upset_df)
```

### Assessing sample sequencing depth using rarefaction (accumulation) curves

This is beta functionality that has not been systematically validated.
The functions are well-written and should run, but we encourage you to interpret their output critically and with the context of your domain-specific knowledge.
Feel free to reach out on the [issue tracker](https://github.com/Arcadia-Science/sourmashconsumr/issues) if you have questions. 

The goal of the `from_signatures_to_rarefaction_df()` and `plot_signatures_rarefaction()` functions is to produce a rarefaction curve to assess whether an adequate sequencing depth was reached to capture the complexity of the sample sequenced.
These functions should work on raw or trimmed reads from short or long read sequencing data generated from metagenomes, metatranscriptomes, genomes, transcriptomes, and maybe other types.
Rarefaction curves rely on the abundance of sequences in a sample.
Therefore, it only makes sense to generate rarefaction curves from signatures that were made with FASTQ files and that had abundance tracking turned on.
Further, these curves may be more accurate if you build them with sequences from many samples from similar environments.
In case signatures were built from reads that have not been k-mer trimmed, there is a filtering step that removes minhashes that are only observed in one sample at abundance 1 as these are likely sequencing errors. 
Please note that this filtering process may invalidate downstream rarefaction curve convergence estimation as many of these methods evaluate singletons and doubletons in the data set.

The function `from_signatures_to_rarefaction_df()` may take a while to run. 
We've found it produces fairly consistent results even when signatures are dramatically downsampled with a high scaled value (e.g. `scaled = 100000).
You can downsample your signatures with sourmash prior to reading them into R using the function `sourmash sig downsample`. 
See the [sourmash documentation](https://sourmash.readthedocs.io) for more details. 

```{r signature_rarefaction}
data(gut_signatures_df)

# filter to a single k-mer size
gut_signatures_df <- gut_signatures_df %>%
  dplyr::filter(ksize == 31)

rarefaction_df <- from_signatures_to_rarefaction_df(signatures_df = gut_signatures_df)
head(rarefaction_df)
```

```{r plot_signatures-rarefaction}
rarefaction_plt <- plot_signatures_rarefaction(rarefaction_df = rarefaction_df, fraction_of_points_to_plot = 1)
rarefaction_plt
```

The plot produced by `plot_signatures_rarefaction` is a ggplot2 plot, so you can modify it by adding additional layers:
```{r plot_signatures_rarefaction_mod}
rarefaction_plt +
  ggplot2::theme_minimal()
```

Color by sample name:
```{r plot_signatures_rarefaction_mod2}
rarefaction_plt +
  ggplot2::theme_minimal() +
  ggplot2::geom_point(ggplot2::aes(color = name))
```

Add your own metadata to the `rarefaction_df` and use it in the plot:
```{r plot_signatures_rarefaction_mod3}
# create a metadata data frame 
run_accessions <- c("SRR5936131", "SRR5947006", "SRR5935765",
                    "SRR5936197", "SRR5946923", "SRR5946920")
groups <- c("cd", "cd", "cd", "nonibd", "nonibd", "nonibd")
metadata <- data.frame(run_accessions = run_accessions, 
                       groups = groups) 

# join the metadata data frame with the rarefaction_df
rarefaction_df <- rarefaction_df %>%
  dplyr::left_join(metadata, by = c("name" = "run_accessions"))

# create and modify a plot
plot_signatures_rarefaction(rarefaction_df = rarefaction_df, fraction_of_points_to_plot = 1) +
  ggplot2::theme_minimal() +
  ggplot2::geom_point(ggplot2::aes(color = groups))
```

## Working with the CSV output of sourmash compare

Sourmash compare outputs an all-by-all similarity matrix for a group of samples. 
When the samples were sketched with abundance tracking as was done here (e.g. the abundance of each k-mer was recorded), the similarity matrix encodes the angular distance.
The sourmashconsumr package supports two visualizations from the CSV output of sourmash compare, an MDS (ordination) plot and a clustered heat map. 

### MDS plot from sourmash compare output

```{r}
fpath <- system.file("extdata", "gut_compare.csv.gz", package = "sourmashconsumr")
gut_compare_df <- read_compare_csv(fpath)
gut_compare_df
```

The MDS plot allows you to visualize how similar each sample is to every other sample in two dimensional space. 
Samples that cluster more closely together are most similar.

```{r}
gut_compare_mds_df <- make_compare_mds(gut_compare_df)
head(gut_compare_mds_df)
```

```{r}
compare_plt <- plot_compare_mds(gut_compare_mds_df)
compare_plt
```

The MDS plot is a ggplot2 object, so you can modify it by adding layers.

```{r}
compare_plt +
  ggplot2::theme_minimal()
```

You can also add metadata directly to the data frame output by `make_compare_mds` so that you can add it to a plot:

```{r}
gut_compare_mds_df %>%
  dplyr::left_join(metadata, by = c("sample" = "run_accessions"))

plot_compare_mds(gut_compare_mds_df) +
  ggplot2::geom_point(ggplot2::aes(color = groups))

```

### Heatmap from sourmash compare output

The `plot_compare_heatmap` object works directly on the output of `read_compare_csv()`.
It's a wrapper function for `base::heatmap()`, so you can add any arguments accepted by `base::heatmap()` to modify the look of the plot.

```{r, fig.height=5, fig.width=6}
plot_compare_heatmap(gut_compare_df, cexRow = 0.75, cexCol = 0.75)
```
    
## Working with the CSV output of sourmash gather

Sourmash gather compares a query (here, a metagenome) against a database (here, GTDB representatives) and provides the minimum set of genomes the cover all of the k-mers in the query that are in the database.

Sourmash gather works best for metagenomes from environments that have been sequenced before or from which many genomes have been isolated and sequenced. 
Because k-mers are so specific, a genome needs to be in a database for sourmash gather to find a match. 
Sourmash gather won't find much above species (k = 31) or genus (k = 21) similarity, so if most of the organisms in a sample are new, sourmash won't be able to label them.

Sourmashconsumr produces two plots from the sourmash gather results: a high-level bargraph summarizes the fraction of the sample that had matches in the database, and an upset plot showing intersections between genomes that were matched in multiple samples.
These plots are designed to visualize the output of running sourmash gather on many samples in the same plot.

### Fraction classifed plot from sourmash gather output

The actual number that is plotted is referred to as abundance-weighted unique fraction. By default, sourmash gather returns the following information:

+ `intersect_bp`: the estimated number of base pairs that overlapped between the query and the matched genome
+ `f_orig_query`: the fraction of the original query (metagenome sample) that matched against the genome
+ `f_match`: the fraction of the genome in the database that matched against the original query (metagenome sample)
+ `f_unique_to_query`: the fraction of the matched genome that was unique to the query. Given that multiple matched genomes could cover the same portion of the query, this column reports the fraction of the query that was covered by the a matched genome, but doesn't allow multiple genomes to cover the same portion. As such, the genome that covers the most k-mers in a metagenome sample gets to "anchor" those k-mers, while other genomes that could cover those k-mers don't get any of them. This column removes the double counting problem that arises from having multiple genomes in a database that contain some of the same sequences.
+ `f_unique_weighted`: This column weights the f_unique_to_query by the abundance of those k-mers. This is important in the context of a metagenome, as the abundance reflects the abundance of the genome in the original microbial community.

The plots below use f_unique_weighted to look at the taxonomic composition of each metagenome sample.

```{r}
data(gut_gather_df)

plot_gather_classified(gather_df = gut_gather_df)
```

### Upset plot from sourmash gather output

An upset plot is an alternative to a venn diagram; the bottom half of the plot shows which samples have shared content while the top half of the plot shows the size of the intersection between the specified samples.

This upset plot visualizes the intersection of genomes that were identified in different samples. 

```{r}
gut_gather_upset_df <- from_gather_to_upset_df(gather_df = gut_gather_df)
head(gut_gather_upset_df)
```

```{r, fig.width = 8}
plot_gather_upset(upset_df = gut_gather_upset_df)
```

The bars in the upset plot can optionally be colored by the database the match came from.
This is useful when you use many databases when running sourmash gather.
Since we only used one database to classify our samples in the example data, the visualization isn't much more rewarding.

```{r, fig.width = 11}
plot_gather_upset(upset_df = gut_gather_upset_df, color_by_database = T, gather_df = gut_gather_df)
```

## Working with the CSV output of sourmash taxonomy annotate

Sourmash taxonomy makes the sourmash gather output more interpretable. 
Sourmash gather only outputs the statistics about the samples in a database that were found in a query sample.
Taxonomic labels contextualize these results and allow new analyses like agglomeration up the taxonomic lineage to summarize results or visualizing results in the context of taxonomy.

### Reading sourmash taxonomy annotate outputs into R

```{r}
data(gut_taxonomy_annotate_df)
```

### Agglomerating up levels of taxnomy

Inspired by `phyloseq::tax_glom()`, this method summarizes variables output by sourmash gather from genomes that have the same taxonomy at a user-specified taxonomy rank.
Agglomeration occurs within each sample, meaning the variable is only summed within each query_name. 
This function returns a data frame with the columns 'lineage', 'query_name', and the variable that is specified by `glom_var`.

```{r}
glom_df <-  tax_glom_taxonomy_annotate(taxonomy_annotate_df = gut_taxonomy_annotate_df,
                                       tax_glom_level = "genus",
                                       glom_var = "f_unique_to_query")

head(glom_df)
```

### Visualizing shared taxonomic lineages between samples with an upset plot

```{r}
gut_taxonomy_upset_inputs <- from_taxonomy_annotate_to_upset_inputs(taxonomy_annotate_df = gut_taxonomy_annotate_df, 
                                                                    tax_glom_level = "phylum")

head(gut_taxonomy_upset_inputs$upset_df)
```

```{r, fig.width=6, fig.height = 6}
plot_taxonomy_annotate_upset(upset_inputs = gut_taxonomy_upset_inputs, 
                             fill = "phylum")
```

### Visualizing the taxonomy of a single sample with a sankey plot
### Visualizing taxonomic changes over time with a time series alluvial plot
### Converting from taxonomy annotate to phyloseq object
### Converting from taxonomy annotate to a metacoder object



* sourmash taxonomy annotate csv
    * `read_taxonomy_annotate()`
    * taxonomy agglomeration: `tax_glom_taxonomy_annotate()`
    * sankey plot:  `plot_taxonomy_annotate_sankey()`
    * time series alluvial plot: `plot_taxonomy_annotate_ts_alluvial()`
    * to metacoder: `from_taxonomy_annotate_to_metacoder()`
    * to phyloseq: `from_taxonomy_annotate_to_phyloseq()`
     
## Upset utility functions

The sourmashconsumr package includes utility functions to create and work with upset-formatted data frames.
These data frames record the presence-absence of the value that is intersected between many samples

* upset utilities
    * `from_list_to_upset_df()`
    * `from_upset_df_to_intersection_members()`
    * `from_upset_df_to_intersection_summary()`
    * `from_upset_df_to_intersections()`
    
SHOW THE HEAD OF AN UPSET DATAFRAME TO CONTEXTUALIZE THE FORMAT.


